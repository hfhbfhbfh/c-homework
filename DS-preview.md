# 第一章 基础 
 
  ## 一、基本概念
   1. 逻辑结构  
    线性结构，树形结构，图结构，集合结构 
   2. 存储结构   
    顺序存储结构，链式储结构  
   3. 算法时间复杂程度

# 第二章 线性表  

## 一、顺序存储 ## 
- 存储地址连续  
    见 ds-1.h

## 二、链式存储 ## 
  - 存储地址可能不连续
    1. 普通单链表操作简述  
        - 插入操作（传入 i ，插入成为下标为i+1， i>-1 && i< n-1 ）  
        判断越界-查找（直接指向下标为i的元素）-申请-分类（头前或正常）-插入-更新  
        
       - 删除操作（）  
        判断越界-查找（指向下标i的前置节点，若为头节点则指向头节点）-分类（头节点或其他）-删除-更新  
        
       - 撤销操作  
        注意保存后置节点，防止断链  
    
    2. 带表头的单链表与普通单链表区别在于：带表头的单链表初始化时，head指针申请了动态空间，该动态空间的指针域指向链表，数据域为空，相当于比普通单链表多了一层首结构，使得每个节点都有前驱节点；
    
    3. 单循环链表  
    
        最后一个节点的指针域指向头节点
    
    4. 双向链表  
      
       - 节点结构：左指针域 数据域 右指针域  
      
       - 基本操作  
      
         - 插入操作（在 下标i的元素前插入）  
          p指向i，q待插入（共有四个指针域待处理）  
          //优先处理待插入节点的两个指针  
          q->llink = p->rlink;  
          q->rlink = p;  
          //剩余两个  
          p->llink->rlink = q；    
          p->llink=q; 

          - 删除操作（删除 下标为i,p指向待删除元素)  
          p->llink->rlink=p->rlink;  
          p->rlink->llink=p->llink;
    
    5. 多项式问题

# 第三章 堆栈与队列 

## 一、堆 ##

### （1）顺序存储 ###
- 存储特点：先进后出
- 中缀，后缀表达式 
  - #### 中缀转后缀  
      算法步骤：  
      1. 初始化栈，#入栈（栈内外优先级都为0）  
      2. 从左到右扫描表达式  
        (1)若当前元素为操作数，直接输出   
        (2)若当前元素为右括号），连续出栈输出知道遇到左括号；//出栈为止，左括号出栈不输出  
        (3)若当前扫描元素为操作符或左括号，则将该元素的栈外优先级与栈顶元素的栈内优先级比较，若小于等于，则连续输出，直到扫描元素的栈外优先级大于栈顶元素的栈内优先级，此时停止出栈，并入栈扫描元素；（栈内优先级应该是由栈低到栈顶递增的）
  - #### 后缀转中缀   
      算法步骤     
        从左往右扫描后缀表达式，遇到操作数入栈，遇到操作符，则在栈中弹出两个操作数并执行该操作运算，结果入栈，重复进行以上操作直到表达式扫描结束；


- 最小堆//见二叉树章节
 ## 二、队列 ##
 
 ### （1）顺序存储 ###
 - 存储特点：先进先出
 - 循环队列（解决假溢出问题）
   - 假溢出：普通队列入队，判断空间大小，rear+1，入队；出对操作，front+1，出对；出对操作会产生空间足够但是front=rear+1即队满现象 ；
   - 循环队列操作：
     - front前进一个单元：front=(front+1)%maxSize;
     - rear前前进一个单元：rear=(rear+1)%maxSize;
     - 判空：front==rear;
     - 判满；(rear+1)%maxsize == front;  
      //此时还有一个front指向的元素区域未被使用
  
  
# 第四章 数组
  
  ## 普通数组   
  
  ### （1）存储规则   
  - 行优先顺序、列优先顺序   
  - 多维数组   
    - 对于 a[m1][m2][m3]...[mn]   
      a[i1][i2][i3]...[in]存储地址为loc([a[0][0][0]...[0])+(i1*m2*m3*...*mn+i2*m3*...*mn+...+in)*sizeof(Elem Type)
  
  ## 特殊矩阵   
 
  ### （1）对称矩阵 --> 压缩为一维矩阵 
  - 对于n个元素的对称矩阵，只需要分配n(n+1)/2空间的数组存储上下三角与对角元素即可   
  - 存储规则(推导过程省略，注意下标，n实际意义)   
    -  存储下三角    
        行优先-> k=i(i+1)/2+j   (j <= i)   
        列优先-> k=j(2n-j-1)/2+i (j <=i)   
    - 存储上三角   
        行优先-> k=i(2n-i+1)/2+j (i <=j)   
        列优先-> k=j(j+1)/2+i (i <=j)   
    
    ### （2）三角矩阵 --> 压缩为一维矩阵
    - 对于n个元素的三角矩阵，只存在上下三角，其他空间为一常数，则需要n(n+1)/2+1个空间，参照对称矩阵的存储，最后一个存放常数

    ### （3）稀疏矩阵  --> 压缩为一维矩阵 
    - 矩阵非0元素占比即矩阵稠密度很小   
    - 存储规则 （存储时，下标与非零数据元素需一起存储，否则无法恢复）  
      - 行三元：行优先规则存储   
      - 列三元：列优先规则存储   
    - 稀疏矩阵的转置算法   
      - 简单转置 ：交换i，j后再排序   
      - 快速转置法 O(n+t)   
        - 辅助矩阵（大小为n，即原稀疏矩阵的列数）   
             
             数组num-> num[j]统计列号为j的非0元素个数   
             
             数组k-> k[j]表示从0列到j-1列的非0元素个数总和,即列标为j的第一个非0元素在转置后矩阵中的存储位置（举例，k[2]=4,则转置前列标为2的第一个非0元素在转置后矩阵存储起点为下标4）   
            
             关系：k[j]=k[j-1]+num[j-1] 
        - 快速转置思路注意：对每个j去访问k[j]后下标加1，表示改列下一个非0元素在矩阵中的存储位置。

# 第五章 二叉树   

## 一、二叉树基本性质

### （1）基本二叉树性质   
- 二叉树第i(i>=1)层上最多有2^(i-1)个节点
- 高度为h的二叉树上至多有2^h-1个节点   
- 包含n个节点的二叉树高度至少为log2(n+1)的向上取整，最大为n
- 任意二叉树中，若叶节点的数量为n0，度为2的节点数量为n2，则n0=n2+1   
    - 证明推导：二叉树除根节点外每个节点都有边进入，每条边都是由度为1或2的节点发出来的，二叉树仅包括度为0、1或2的节点。   

### （2）满二叉树   
- 定义：高度为h的二叉树恰好有2^h-1个节点   

### （3）完全二叉树   
- 定义；一颗二叉树只有最下面两层的节点可以小于2，且最下层叶子节点集中在靠右的若干位置上。
- 性质1：具有n个节点的完全二叉树的高度为log2(n+1)向上取整
- 性质2:对于n个元素的完全二叉树，按层次遍历输出的顺序编号（0～n-1）   
  - i=0，则为根结点   
  - i>0,则该节点的双亲编号为(i-1)/2向下取整   
  - 2i+1 < n,则该节点存在左孩子且编号为2i+1   
  - 2i+2 < n,则该节点存在右孩子且编号为2i+2

### （4）扩充二叉树，2-数
- 定义：不存在度为1节点的二叉树

## 二、二叉树基本操作     
- 见二叉树操作.c文件 //-----------------------待补充！！！！！

## 三、二叉树与森林的转换   

### （1）森林转化为二叉树   
  - 1、连线：森林中各树的根连起来，并将森林中具有兄弟关系的节点用线连起来；   
  - 2、去线：去掉双亲到除了第一个孩子以外的孩子的连线，只保留到第一个孩子的连线   
  - 3、倾斜：按习惯调整二叉树形 

### （2）二叉树转化为森林
  - 1、连线（递归）：若该节点存在左孩子，则把该左孩子节点的右孩子，其右孩子的的右孩子作为该节点的孩子节点，并连线   
  - 2、去线：删去所有节点于其右孩子的连线   
  - 3、调整森林树形

## 四、最小堆  
- 建堆操作与优先权队列pop后的向下调整算法，优先权队列加入一个元素后的向上调整算法->核心都在于完全二叉树的编号性质

## 五、哈夫曼

### （1）基本概念
- 树的内径长度：除叶节点外，从树根到其他所有节点的路径长度之和；   
- 树的外径长度；树根到所有叶节点的路径长度之和；
- 叶节点的加权路径长度：树根到改叶节点的路径长度与该叶节点权值的乘积 
- 树的加权路径长度（WPL）：所有叶节点的加权路径长度之和
- 扩充二叉树：内路径长度I,外路径长度E,n为非叶子结点个数；则   
    E = I + 2n;

### （2）哈夫曼树的构建（最小加权路径长度的扩充二叉树）
- 优先权队列中找出两个最小根权值的树，合并为新树，并将新的树根放回原优先权队列直至队列只剩下一个元素（合并规则，左小）

### （3）哈夫曼编码解码
- 编码： 从根开始遍历哈夫曼树，走左孩子则标记0，右孩子标记1，知道访问到叶子节点，返回跟节点重复以上步骤
- 解码； 扫描码文，按照以上规则输出译码字符，输出一个后重新从根节点开始继续扫描；

# 第六章  集合与搜索

## 顺序搜索 
  - 没什么好讲的  
  - 平均搜索长度   
    - 成功: (n+1)/2   
    - 失败   
      无序表: n   
      有序表: n/2+2
## 对半搜索（有序表）
  - 递归形式与迭代形式的代码

## 二叉判定树

### 1、二叉判定树的建立   
（1）根据元素个数n，寻找满二叉树层数k即 2^k-1< n <2^(k+1)-1   

（2) 根据一下规则插入剩余元素           
   - 若当前判定树元素为偶数，则右子树元素比左子树元素多1   
   - 若当前判定树元素为奇数，则左右子树元素个数相等     
   
（3）按中序输出的顺序填入对应元素      

（4） 搜索失败情况的外部节点：若外部节点为右孩子，其序号为双亲节点，若为左孩子，则为双亲序号-1

### 2、平均搜索长度计算   
（1）注意，搜索失败的平均搜索长度是对所有外部节点而言即，根节点为第一层   
  - ASL(F)=sigma（本层高度*本层外部节点数）/总外部节点数
  - ASL(S)=sigma（本层高度*本层节点数）/总节点数 
  
  
  
  
  
  
  
  
# 第七章 搜索树 

## 一、基本概念   
- 定义：   
  - （1）任意两个节点关键字不相同   
  - （2）若左子树不空，则左子树上所有节点的关键词均小于根节点的关键词值   
  - （3）若右子树不空，则右子树上所有节点的关键词均小于根节点的关键词   
  - （4）左右子树也是二叉搜索树   
- 性质；以中序遍历一颗二叉搜索树，将得到一个关键词递增的有序序列   

## 二、基本操作
- 1、二叉搜索树的搜索 （没啥好讲，关键词大小比对，递归或者迭代）

- 2、二叉搜索树的插入
  - （1）类似迭代搜索，排重，并找到插入位置   
  - （2）申请动态空间并按规则插入

- 3、二叉搜索树的删除  
  - 三种情况：   
    - a. 删除叶节点-->直接删
    - b. 删除只有一颗非空子树的非叶节点-->用非空子树的根节点代替其位置
    - c. 删除有两颗非空子树的非叶节点-->找到左子树的最大关键词节点（中序前驱）或者右子树最小关键词节点（中序后继）并交换数据，将问题转化为a，b类  //代码后续补上   
- 4、二叉平衡树   
  - 定义；最坏情况下高度为O(log2n)的二叉搜索树，有效控制高度，避免搜索树的"退化"
  - 性质：   
    - （1）根的左右子树的高度差绝对值不超过1(平衡因子)  
    - （2）根的左右子树均为二叉平衡树
    - 拥有排序性（中序输出递增）与平衡性（左右高度差绝对值不大于1）的性质   
  - 二叉平衡树的调整方法   
    - s是离插入元素最近的平衡因子绝对值大于1的节点为根节点形成的最小子树，   
    - 单旋转(LL或RR情况)   
      （1）标记出s沿插入新元素路径上的下一个节点r   
      （2）以r为新的根节点调整s最小子树的平衡性，恢复高度
    - 双旋转(LR或 RL)   
      （1）标记出s沿插入元素路径上的下一个节点r与r的下一个节点u   
      （2）已u节点为新的根节点调整最小子树的平衡性
    - 这里不提供代码，也不好赘述，调整画图的要定在于二叉平衡树的排序性，即中序输出关键词递增序列。   

- 5、m叉搜索树（外搜索）
  - 性质：   
    - 对于m叉搜索树，一个节点最多存放m-1个元素与m个指针（即最多有m个子树）   
    - 每个节点的关键词按递增排序，一个元素的关键词大于其左子树上所有节点中的元素，小于右子树上所有节点的元素   
    - 某个节点元素个数为N,失败节点（空指针）个数为S,则 N = S - 1
    - 高度为h的m叉搜索树中最多有m^h-1个元素
    - 含有N个元素的m叉搜索树高度在logm(N+1)到N之间

- 6、m阶B-树（m叉搜索树）
  - 定义   
    （1）根节点至少有两个孩子   
    （2）除跟节点和失败节点外的每个节点至少有 m/2向上取整个孩子，即 m/2向上取整-1(m/2) <= 关键词个数 <= m-1   
    （3）所有失败节点均在同一层上   
  - 插入元素的调整算法   
    （1）搜索：搜索成功则插入结束，搜索失败，则转步骤（2）将新元素插入搜索失败节点的上一层叶节点（设为q）   
    （2）插入：新元素和一个新空指针插入q，若未上溢出（即关键词个数大于m-1）则成功，否则进行步骤（3）；   
    （3）分裂：（此时q节点有m个关键词）以ｍ/2向上取整（记为pivot=m/2+1）为分割点将q一分为三，第一个元素到pivot-1的位置留在q节点内，pivot+1到m的位置存放在新创建的节点p中；讲分割点元素与新创建的p节点放在q的双亲节点中，继续向上检查溢出，若有则重复步骤3，否则结束算法；   
  - 删除元素的调整算法   
    （1）搜索：搜索失败，结束算法，搜索成功则执行删除操作   
    （2）判断删除类型   
      a.删除元素在叶节点，转步骤3    
      b.删除有素不在叶节点，则用该元素右子树上最小元素替代它，转化为情况a，   
     （3）叶节点中删除元素，首先从叶节点中直接删除该元素，若没有下溢出，则结束；否则首先考虑"借"方法处理（借的操作约定，先左后右，采用旋转的方法借），若左右兄弟都没有富余，则采用"并"的方法处理下溢出（并的操作同样约定先左后右，讲该节点与兄弟节点和双亲节点中分割他们的元素并成一个节点存放在兄弟节点中），重复操作直至没有溢出问题。

# 第八章 散列表
## 一、
- 散列函数（哈希函数），冲突，解决冲突技术（溢出 技术处理）
## 二、 冲突处理

### 1、开散列法（另开地址）  
- （1）、拉链法（即对应散列地址下创建单链表，通过单链表的延长解决冲突）  
  - 问题：极端情况下，所有元素聚集在一个地址下的单链表中   
  - 解决方案：引入装填因子   

### 2、闭散列法（开地址法）-指在散列表内开放地址
- （1）、线性探查法   
  - 探查序列 hi(key)=(h(key)+i) mod M  (0 <= i <=m-1)
  - 问题：线性聚集   
- （2）、二次探查   
  - 探查序列    
      h2i-1(key)=(h(key)+i^2) mod M   
      h2i(key)=(h(key)-i^2) mod M (i > 0)
  - 问题：二次聚集   
- （3）、双散列法   
  - 运用两个散列函数 h1,h2
  - 探查序列   
      Hi=(h1(key)+i*h2(key)) mod M  


# 第九章 图论   
## 一、基本术语   
- 邻接（关联）；   
- 顶点的度，出度，入度；
- 路径和路径长度   
- 自回路与多重图   
- 完全图    
  - n个节点的无向完全图有最多n(n-1)/2条边   
  - n个节点的有向完全图有最多n(n-1)条边   
- 子图   
- 联通图：图中任意两个顶点都是联通的   
- 强联通图：图中任意两个顶点都是互相可达的（即对于顶点u，v，u可达v，v可达u）
- 生成树，生成森林//。。。刷到题目再看  
- 权和网：每条边都被赋予权值即成网
## 二、基本操作  //见图论操作.h
- 邻接表   
- 邻接矩阵
- 图的遍历   
  - 深度优先遍历   
  - 广度优先遍历
## 三、拓扑排序   
- AOV网：具有领先关系的有向图
- AOV网的拓扑排序  
  - 算法思路：   
  （1）在图中选择一个入度为0的顶点并输出  
  （2）在图中删除该顶点及其所有出边   
  （3）重复步骤1，2直至不存在入度为0的边，若此时输出顶点个数小于原图中顶点数，说明图中存在有向回路，否则，输出序列即为拓扑序列   
## 四、关键路径   
- AOE网只有一个入度为0的顶点（源点）表示工程开始，一个出度为0的顶点（汇点）表示工程结束；   
- 关键路径：是指从源点到汇点的最长路径；完成工程所需最短时间是关键路径的长度，关键路径上的活动称为关键活动；
## 五、最小代价生成树   
- 普里姆算法（指定顶点最小代价生成树）   
（1）初始状态下，生成树仅有一起点；   
（2）在所有生成树顶点所关联的未标记的边中找出权值最小的，并将此边与对应顶点进行标记；   
（3）重复步骤2直到所有顶点都被标记；   
- 克鲁斯卡尔算法（不指定顶起点）   
（1）初始状态所有顶点都被标记；   
（2）在所有未被标记的关联边中找出权值最小，其不会形成回路的边进行标记    
（3）重复步骤2直至标记边数量为n-1   

## 六、单源最短路径
- 狄杰斯特拉算法-----O(n^2)
  - 三个辅助数组，s-标记顶点访问情况  d-标记从源点到其他顶点的最短路径的长度 path-每个最短路径下各顶点的前驱顶点
  - 是一种动态更新排序，每次通过d数组里最小值来选择下一个顶点，并在每个顶点的考察中跟新d与path的数据   
   
## 七、所有顶点的最短路径
-弗洛伊德算法--O(n^3)//又不想看了，等待需求输入再来写吧  2020/1/2

# 第十章 内排序算法 

  ## 一、简单排序  
  - 算法思路  
        每一趟中，在待排序序列中找出最小的元素，与待排序序列第一个元素交换位置，并将该元素移出下一组待排序序列，从序列为原数组开始重复该过程直到待排序序列只剩下一个数据，结束算法；

  - 算法分析  
    - 稳定性   
      不稳定
    - 排序过程  
      对于n个元素，进行n—1次排序，每次排序进行三个操作：找出待排序序列中最小元素，交换最小元素与待排序序列首元素，调整下一次待排序序列起始下标（即前一个加1即可）
    - 空间复杂度  
      O(1)--用于交换元素的临时变量  
    - 时间复杂程度   
      最好，最坏和平均情况的时间复杂程度都是O(n^2)

## 二、直接插入排序
  - 算法思路  
        从只包含一个数据元素的有序序列开始，不断的将待排序序列的元素有序的插入改有序序列中（即不断的将有序序列中的元素后移，直到待插入元素可以有序插入），直到改有序序列包含所有数据元素；
 
  - 算法分析
    - 稳定性     
      稳定的
    - 排序次数  
      对于n个元素，执行n-1次
    - 空间复杂程度  
      O(1)--待插入元素的临时存储变量
    - 时间复杂程度  
      最好情况：O(n)   
      最坏与平均情况：O(n^2)

## 三、冒泡排序
 - 算法思路  
      从前向后不断交换相邻逆序数据，重复该过程，直到任意相邻元素都不在逆序排列为止。（即小数据往上冒，大数据往下沉，实现升序排列数据）  

 - 算法分析   
    - 稳定性   
      稳定的   
    - 排序次数   
      对于n个元素，有两种终止情况：第一种即所有有序，只进行1次排序；第二种即每次都有元素交换位置，此时需要n-1次排序   
    - 空间复杂程度   
     O(1)--用于交换的临时变量   
    - 时间复杂程度   
      最好情况：只排序一次，为O(n);   
      最坏与平均情况：O(n^2)

## 四、快速排序   
 - 算法思路   
      在待排序序列中找一个分割元素，将所有比分割元素小的或相等的元素移动至分割元素之前，比它大的则移动到分割元素后面，然后将分割元素的左右子序列看成待排序序列，重复上述操作；   
 
 - 算法分析   
    - 稳定性   
      不稳定   
    - 排序次数   
      最坏情况：每次排序都使得元素聚集在分割元素的一侧，需要n-1次排序   
      最好情况：每次序列划分都是的原序列分成基本等长的两个子序列，此时的快拍趟数满足公式；   
    - 空间复杂程度   
      由于使用了递归的方式，调用了系统栈存储递归的结果所以   
      最好情况：O(log2n)   
      最坏与平均情况：O(n)   
    - 时间复杂程度   
      最好情况：O(nlog2n)   
      最坏与平均情况：O(n^2)   

## 五、两路合并排序
 - 算法思路  
    初始时将n个待排序序列看成n个待合并的有序序列，每个序列只包含一个元素，将m个待合并序列合并成一个大的有序序列；重复合并过程直到所有元素都属于一个有序序列；m=2时称为两路合并排序；  

 - 算法分析   
   - 稳定性   
     稳定的    
   - 排序次数   
     N=log2n 向上取整   
   - 空间复杂程度   
     最后一个临时存储空间为最大，n个单位（这种情况在数据较大时，如果依把改临时空间放在函数体内，会导致函数调用堆栈大小大于规定大小，目前优化方案为把改临时存储空间设置为全局变量，有待优化）即为O(n);   
   - 时间复杂程度   
     O(nlog2n)

## 六、堆排序   
 - 算法思路   
   借助最小堆的数据结构与特殊性质，不断输出堆顶元素（当前集合最小元素），然后继续调整剩余序列为最小堆，重复上述操作直到堆中只剩下一个元素；   

 - 算法分析  
   - 稳定性   
     不稳定的
   - 排序次数    
     n个规模的元素，需要n-1次的排序   
   - 空间复杂程度   
     O(1)--交换元素的临时变量   
   - 时间复杂程度   
     O(nlog2n)


